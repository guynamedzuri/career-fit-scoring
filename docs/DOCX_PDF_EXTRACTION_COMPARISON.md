# DOCX 폼 vs PDF 폼 추출 형태 비교

동일한 자체 이력서 폼을 **DOCX**로 접수할 때와 **PDF로 변환해** 접수할 때, 추출 결과가 어떻게 다른지 정리한 문서입니다.  
샘플: `docx_resume_to_pdf.pdf` (DOCX 폼을 그대로 PDF로 저장한 파일).

---

## 1. pdftotext 추출 결과 (PDF)

**명령**: `pdftotext -layout -enc UTF-8 docx_resume_to_pdf.pdf -`  
**전체 출력**: 프로젝트 루트 `docx_resume_to_pdf_pdftotext.txt` (135줄)에 저장됨.

### 특징

- **형식**: 평문 텍스트. `-layout`으로 인해 줄바꿈·공백으로 **화면 레이아웃이 어느 정도 유지**됨.
- **테이블**: 셀 경계 없음. 표는 **줄 단위 + 공백으로 정렬된 텍스트**로만 나옴.
- **구역 구분**: `▣ 기본 인적사항`, `▣ 학력사항`, `▣ 경력사항`, `▣ 어학(최근2년 취득) / 자격사항 / 수상경력`, `자 기 소 개 서`, `경 력 기 술 서` 같은 **헤더 문자열**로 섹션을 구분할 수 있음.
- **필드 인식**: “라벨 + 값”이 한 줄에 나오거나, 여러 줄에 걸쳐 나옴.  
  - 예: `지원분야            공무, 시설관리`, `희망연봉                 3700 (만원)`, `생년월일                1995년 09월 21일            e-mail        sgh8966@naver.com`
- **학력/경력**: 헤더 행 다음에 데이터가 **열 정렬(공백)** 형태로 나옴.  
  - 학력: `입학년월       졸업년월                학교명 ...` 다음에 `2014.03    2020.08                원광대학교           전자공학과 ...`  
  - 경력: `입사년월       퇴사년월              회사명 ...` 다음에 `2024.07    2025.07        (주)세명테크 ...`
- **자기소개서**: “자기소개(700자이내)”, “지원동기(700자이내)” 등 **소제목 + 본문**이 이어지는 블록. 본문은 여러 줄에 걸쳐 있음.
- **경력기술서**: “입사년월 / 퇴사년월 / 회사명 / …” 한 행 다음에 **상세내용** 블록이 여러 줄로 이어짐.

### 파싱 시 필요한 작업 (PDF)

1. **pdftotext**로 위와 같은 평문 텍스트 추출 (이미 수행함).
2. **섹션 분할**: `▣ …`, `자 기 소 개 서`, `경 력 기 술 서` 등으로 구역 나누기.
3. **기본 인적사항**: 라벨(지원분야, 희망연봉, 성명, 생년월일, e-mail, 현 주 소, 연 락 처, 병역사항 등)을 기준으로 정규식 또는 “다음 라벨 직전까지”로 값 추출.
4. **학력/경력/자격 테이블**: 헤더 행으로 열 위치(또는 고정 폭) 추정 후, 데이터 행을 열별로 잘라 매핑. 또는 `YYYY.MM` 패턴 등으로 줄 단위 파싱.
5. **자기소개서**: 4개 블록(자기소개, 지원동기, 성과목표달성경험, 장래포부)을 소제목으로 구분한 뒤, 각 블록 본문만 추출.
6. **경력기술서**: 회사별로 “입사/퇴사/회사명/…” 행 + “상세내용” 블록을 묶어서 파싱.

---

## 2. DOCX 추출 결과 (기존 방식)

**도구**: `scripts/extract_resume_form_structure.py` + `src/resumeMapping.ts`  
**형식**: DOCX 내부 **테이블 구조**를 그대로 읽어, **테이블 인덱스 · 행 인덱스 · 열 인덱스**로 셀 단위 접근.

### 특징

- **형식**: `tables[table_index].rows[row_index].cells[cell_index].text` — **셀 경계가 명확**함.
- **매핑**: `resumeMapping.ts`의 `DEFAULT_RESUME_MAPPING`처럼 “테이블 0 = 기본 인적사항, (1,1)=이름, (3,3)=이메일 …” 식으로 **고정 인덱스**만 알면 됨.
- **테이블 구성** (현재 양식 기준):
  - **테이블 0**: 기본 인적사항 (행 1~6: 성명, 영문, 생년월일, 주소, 연락처, 병역 등 / 열 1, 3, 5 등으로 값 위치 고정)
  - **테이블 1**: 학력 (헤더 1행, 데이터 2~7행, 열 2=학교명, 3=전공, 4=학점, 6=졸업구분 등)
  - **테이블 2**: 경력 (헤더 1행, 데이터 2~6행, 열 0=입사, 1=퇴사, 2=회사명, 4=직위, 6=이직사유 등)
  - **테이블 3**: 어학/자격/해외연수/수상 (같은 테이블 내 행·열 구간으로 구분)
  - **테이블 4**: 자기소개서 (행 1,3,5,7 / 열 1 = 4개 답안)
  - **테이블 5**: 경력기술 상세 (블록별 header/data/detail 행 + 열 0~6)
- **추가 정보**: 셀 내 이미지(증명사진) 유무 등도 추출 가능.

### 파싱 시 필요한 작업 (DOCX)

- **추출**: `python extract_resume_form_structure.py <docx_path>` → 테이블·행·열별 텍스트 JSON.
- **매핑**: 위 JSON에 `DEFAULT_RESUME_MAPPING`을 적용해 `basicInfo`, `education`, `careers`, `certificates`, `selfIntroduction`, `careerDetails` 등으로 변환. **정규식 없이 인덱스만** 사용.

---

## 3. 차이 요약

| 항목 | DOCX (자체 폼) | PDF (동일 폼 PDF화) |
|------|----------------|----------------------|
| **추출 단위** | 테이블·행·열(셀) 단위 | 줄 단위 + 공백 정렬 텍스트 |
| **셀 경계** | 있음 (인덱스로 접근) | 없음 (레이아웃·라벨로 추론 필요) |
| **필드 매핑** | (tableIndex, rowIndex, cellIndex) 고정 매핑 | 섹션 + 라벨/패턴 또는 열 위치 추정 |
| **도구** | python-docx + extract_resume_form_structure.py | pdftotext → 자체 파서(정규식/섹션/열 파싱) |
| **출력** | 동일한 applicationData 구조로 매핑 가능 | 동일 구조를 목표로 하되, PDF 전용 파서 필요 |

---

## 4. PDF 파서 개발 시 방향

- **입력**: pdftotext로 뽑은 텍스트 (예: `docx_resume_to_pdf_pdftotext.txt`와 같은 형태).
- **목표**: DOCX 파서와 **동일한 applicationData**(basicInfo, education, careers, certificates, selfIntroduction, careerDetails 등)를 채우는 것.
- **방법**:
  1. `▣ 기본 인적사항` ~ `▣ 학력사항` 직전까지 구간을 잘라 기본 인적사항 파싱 (지원분야, 희망연봉, 성명, 생년월일, e-mail, 주소, 연락처, 병역 등).
  2. `▣ 학력사항` ~ `▣ 경력사항` 구간에서 헤더 행 + 데이터 행을 열 단위(또는 정규식)로 파싱.
  3. `▣ 경력사항` ~ `▣ 어학…` 구간에서 경력 테이블 동일 방식 파싱.
  4. `▣ 어학…` 구간에서 어학/자격/해외연수/수상 블록 구분 후 각각 파싱.
  5. `자 기 소 개 서` ~ `경 력 기 술 서` 구간에서 4개 자기소개서 블록 파싱.
  6. `경 력 기 술 서` 구간에서 경력기술 상세(회사별 + 상세내용) 파싱.

이렇게 하면 "자체 이력서 폼을 PDF로 제출한 경우"에도 DOCX와 같은 데이터 구조로 넘길 수 있어, 이후 스코어링/AI 평가 로직을 그대로 재사용할 수 있습니다.

---

## 5. 자체 폼 PDF 파서 (초안)

**스크립트**: `scripts/parse_docx_form_pdf.py`

- **입력**: 자체 이력서 폼을 PDF로 저장한 파일 경로. (또는 `--text <txt>`로 pdftotext 추출 결과 파일)
- **출력**: DOCX의 `tablesToApplicationData`와 동일한 **applicationData 형식**(flat key) JSON.
- **의존**: `pdftotext`(poppler-utils).

```bash
python3 scripts/parse_docx_form_pdf.py docx_resume_to_pdf.pdf
python3 scripts/parse_docx_form_pdf.py --text docx_resume_to_pdf_pdftotext.txt
```

초안이라 레이아웃이 많이 달라지면 섹션/정규식 수정이 필요할 수 있습니다.
